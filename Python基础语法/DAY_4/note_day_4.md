# day_4
### 序列的切片操作
- 列表元组字符串均可以视为序列
- **切片：**从一个序列中取出一个子序列
- 语法：`序列[start:stop:step]`
    - start：起始索引，默认为0
    - stop：结束索引，默认为序列长度
    - step：步长，默认为1
## 集合
- **集合：**无序且不重复的元素序列
- 基本语法：
    - `集合 = {元素1, 元素2, ...}`
    - `集合 = set()`
    - 不可以用{}来定义，{}已经被用来定义字典
- **添加新元素**:
    - 语法：`集合.add(元素)`
- **删除元素：**
    - 语法：`集合.remove(元素)`
- **随机取出一个元素：**
    - 语法：`集合.pop()`
    - 删除并返回随机一个元素
- **清空元素：**
    - 语法：`集合.clear()`
- **取出两个集合的差集：**
    - 语法：`集合1.difference(集合2)`
    - 返回集合1与集合2的差集，集合1中的元素且在集合2中不存在
- **消除两个集合的差集：**
    - 语法：`集合1.difference_update(集合2)`
    - 删除集合1中在集合2中存在的元素
- **合并两个集合：**
    - 语法：`集合1.union(集合2)`
    - 返回集合1与集合2的并集，原集合不变
- **统计集合内元素数量：**
    - 语法：`len(集合)`
- 集合**不支持while**循环，但是集合**支持for循环**
- **特点：**
    - 可以容纳多个数据
    - 可以容纳不同类型的数据
    - 数据数无序存储的
    - 不允许重复数据
    - 可以修改
    - 支持for循环
### 字典
- **字典：**无序的键值对序列
- 基本语法：
    - `字典 = {键1:值1, 键2:值2, ...}`
    - `字典 = dict()`
    - `字典 = {}`
- 字典key值不允许重复，如果key值重复，则后面的key值会覆盖前面的key值
- 可以通过key值取出对应的value值：
    - 语法：`字典[key]`
- 字典的key和value值都可以是任意类型(key不可以是字典)
- **字典的嵌套：**
    - 语法：`字典 = {key1:{key2:value2, key3:value3}, key4:value4}`
- **新增\修改**字典元素：
    - 语法：`字典[key] = value`
    - 如果key不存在，则新增一个元素，如果key存在，则修改对应的value值
- **删除元素：**
    - 语法：`字典.pop(key)`
    - 删除并返回对应的key值所对应的value值
- **清空元素：**
    - 语法：`字典.clear()`
- **获取全部key值：**
    - 语法：`字典.keys()`
- **遍历字典：**
    - 语法：`for key in 字典:`
    - 逐个输出字典的key值
- **统计元素数量**:
    - 语法：`len(字典)`
### 数据容器对比
- **是否支持下表索引：**
    - 支持：列表，元组，字符串 --序列类型
    - 不支持：集合，字典 --非序列类型
- **是否支持重复元素**
    - 支持：列表，元组，字符串 --序列类型
    - 不支持：集合，字典 --非序列类型
- **是否可以修改**
    - 支持：列表，集合，字典 
    - 不支持：元组，字符串


| 特性   | 列表               | 元组                | 字符串       | 集合          | 字典                       |
| ---- | ---------------- | ----------------- | --------- | ----------- | ------------------------ |
| 元素数量 | 支持多个             | 支持多个              | 支持多个      | 支持多个        | 支持多个                     |
| 元素类型 | 任意               | 任意                | 仅字符       | 任意          | Key:Value   Key: 除字典外任意类型 Value：任意类型             |
| 下标索引 | 支持               | 支持                | 支持        | 不支持         | 不支持                      |
| 重复元素 | 支持               | 支持                | 支持        | 不支持         | 不支持                      |
| 可修改性 | 支持               | 不支持               | 不支持       | 支持          | 支持                       |
| 数据有序 | 是                | 是                 | 是         | 否           | 否                        |
| 使用场景 | 可修改、可重复的一批数据记录场景 | 不可修改、可重复的一批数据记录场景 | 一串字符的记录场景 | 不可重复的数据记录场景 | 以 Key 检索 Value 的数据记录场景   |


### 数据容器的通用操作：
- **统计元素数量：**
    - 语法：`len(数据容器)`
- **寻找最大元素：**
    - 语法：`max(数据容器)`
- **寻找最小元素：**
    - 语法：`min(数据容器)`
- **类型转换：**
    - list(数据容器)
    - tuple(数据容器)
    - set(数据容器)
    - str(数据容器)
    - 注意，字典进行转换时，会丢失键值对关系，只保留键
- **排序功能：**
    - 语法：`sorted(数据容器,reverse=True/False)`
    - reverse参数为True时，表示降序排列，为False时，表示升序排列
    - 不填写reverse参数时，默认为升序排列
### ASCII码
- 程序中所有的字符都有其对应的ASCII码
- 字符串是按位比较，一位一位匹配，当前位数相同就顺延地比较下一位，直到某一位不同，就返回结果

## 函数进阶
### 函数多返回值
- 可以用`,`隔开多个返回值,例子：


        def test(a, b):
            return a + b, a * b    
- 返回值类型不受限，可以是任意类型
- 接收时也用`,`隔开
### 函数多种传参形式
- **位置参数**：通过位置来确定参数，位置参数必须按照顺序传入
- **关键字参数**：通过参数名来确定参数，关键字参数可以不按照顺序传入

        def test(a, b, c):
            print(a, b, c)
        test(a=1,c=2,b=3)
- 位置参数可以和关键字参数混合使用，但是位置参数必须放在关键字参数前面来确定参数
- **缺省参数：**通过参数名来确定参数，如果参数没有传入，则使用缺省值


        def test(a, b, c=2):
            print(a, b, c)
        test(1,3) #没有输入c参数，则使用缺省值2，不会报错
    - 参数的顺序：位置参数，关键字参数，缺省参数，默认值必须放在最后
- **不定长参数：**
    - ***args：**可变参数，将参数保存在元组中


            def test(*args):
                print(args)
            test(1,2,3)
            结果：
            (1, 2, 3)


    - **kwargs：关键字参数，将参数保存在字典中


            def test(**kwargs):
                print(kwargs)
            test(a=1,b=2,c=3)
            结果：
            {'a': 1, 'b': 2, 'c': 3}
    
### 匿名函数
- **函数作为参数传递**
    - 这是一种函数作为逻辑的传递，而非数据的传递


            def test(fun):
                result = fun(1,2)
                return result
            def add(a,b):
                return a+b
            test(add)
            结果：
            3
    - 意义解析：test()函数要求传入一个逻辑，test()会调用这个逻辑来完成自身的功能，传入函数是什么逻辑可以根据需求去更改对应函数，只要能够接收test()函数给的参数和返回逻辑结果就可以
- **lambda匿名函数：**
    - 函数定义中，**`def`关键字**可以用来定义带有名称的函数，**可以基于名称重复使用**
    - **`lambda`关键字**可以用来定义匿名函数(无名称),无名称的**匿名函数只能使用一次**
    - 语法：`lambda [参数列表]:[表达式]`


            def test(fun):
                result = fun(1,2)
                return result
            test(lambda a,b:a+b)
    - 可以通过传入一个`lambda`匿名函数作为参数，来调用test函数
    - `lambda`只支持一行代码